<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · JuMag.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JuMag.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JuMag.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../equations/">Equations</a></li><li><a class="tocitem" href="../notes/">Notes</a></li><li class="is-active"><a class="tocitem" href>References</a></li><li><a class="tocitem" href="../questions/">Questions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ww1g11/JuMagDocs.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h1><h3 id="Meshes-1"><a class="docs-heading-anchor" href="#Meshes-1">Meshes</a><a class="docs-heading-anchor-permalink" href="#Meshes-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMag.FDMesh" href="#JuMag.FDMesh"><code>JuMag.FDMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a FDMesh for given parameters. <code>pbc</code> could be any combination of &quot;x&quot;, &quot;y&quot; and &quot;z&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/mesh.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.FDMeshGPU" href="#JuMag.FDMeshGPU"><code>JuMag.FDMeshGPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDMeshGPU(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>The GPU version of the FDMesh, which is needed for GPU compuation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/cuda/mesh.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.CubicMeshGPU" href="#JuMag.CubicMeshGPU"><code>JuMag.CubicMeshGPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Create a CubicMeshGPU.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/mesh.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.TriangularMeshGPU" href="#JuMag.TriangularMeshGPU"><code>JuMag.TriangularMeshGPU</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create a 3d triangular mesh.</p><p>The nearest neighbours are indexed as counterclockwise of the given spin:</p><p>|  1      2         3       4         5          6           7      8   |   |right top<em>right top</em>left  left  bottom<em>left bottom</em>right   below  above |</p><p>and the next-nearest neighbours are</p><p>|  1       2        3       4         5          6           7      8   |   |top<em>right top  top</em>left  bottom<em>left bottom bottom</em>right   below  above |</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/mesh.jl#L19-L32">source</a></section></article><h3 id="DataTypes-1"><a class="docs-heading-anchor" href="#DataTypes-1">DataTypes</a><a class="docs-heading-anchor-permalink" href="#DataTypes-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMag.NumberOrArrayOrFunction" href="#JuMag.NumberOrArrayOrFunction"><code>JuMag.NumberOrArrayOrFunction</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NumberOrArrayOrFunction</code></pre><p>In Micromagnetics, typical parameters such as saturation magnetization <code>Ms</code> and exchange stiffness constant <code>A</code> are constant. However, there are many cases that a spatial <code>Ms</code> is needed. For instance, if the simulated system is a circular disk the Ms in the corners should be set to zero. If the simulated system contains mutiple materials, the exchange constant <code>A</code> should be spatial as well. The Union <code>NumberOrArrayOrFunction</code> is designed to deal with such situations. As indicated from its name, it means that the input parameter could be a number or an array or a function:</p><ul><li><p>Number: should be Real.</p></li><li><p>Array: the length of the array should be <code>N</code> where <code>N</code> is the total spin number of the system.</p></li><li><p>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> where <code>i,j,k</code> is the cell index and <code>dx,dy,dz</code> is the cellsize. The return value of the function should be a real number. For example,</p><pre><code class="language-julia">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/head.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.NumberOrArray" href="#JuMag.NumberOrArray"><code>JuMag.NumberOrArray</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">NumberOrArray</code></pre><p>Similar to Union <code>NumberOrArrayOrFunction</code>, the Union <code>NumberOrArray</code> is designed to deal with cases that a number or an array is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/head.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.TupleOrArrayOrFunction" href="#JuMag.TupleOrArrayOrFunction"><code>JuMag.TupleOrArrayOrFunction</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">TupleOrArrayOrFunction</code></pre><p>Similar to <code>NumberOrArrayOrFunction</code>, <code>TupleOrArrayOrFunction</code> means that the input parameter could be a tuple or an array or a function:</p><ul><li>Tuple: should be Real with length 3. For example, <code>(0,0,1e5)</code>.</li><li>Array: the length of the array should be <code>3N</code> where <code>N</code> is the total spin number of the system.</li><li>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> and the return value should be a tuple with length 3. For example,<pre><code class="language-julia">function uniform_m0(i,j,k,dx,dy,dz)
    return (0,0,1)
end</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/head.jl#L40-L54">source</a></section></article><h3 id="Interfaces-1"><a class="docs-heading-anchor" href="#Interfaces-1">Interfaces</a><a class="docs-heading-anchor-permalink" href="#Interfaces-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMag.Sim" href="#JuMag.Sim"><code>JuMag.Sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Sim(mesh::Mesh; driver=&quot;LLG&quot;, name=&quot;dyn&quot;, integrator=&quot;Dopri5&quot;)</code></pre><p>Create a simulation instance for given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L1-L5">source</a></section><section><div><pre><code class="language-none">Sim(mesh::MeshGPU; driver=&quot;LLG&quot;, name=&quot;dyn&quot;, integrator=&quot;Dopri5&quot;)</code></pre><p>Create a simulation instance for GPU mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/cuda/sim.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.set_Ms" href="#JuMag.set_Ms"><code>JuMag.set_Ms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)</code></pre><p>Set the saturation magnetization Ms of the studied system. For example,</p><pre><code class="language-julia">   set_Ms(sim, 8.6e5)</code></pre><p>or</p><pre><code class="language-julia">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end
set_Ms(sim, circular_Ms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L46-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.set_mu_s" href="#JuMag.set_mu_s"><code>JuMag.set_mu_s</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_mu_s(sim::AtomicSimGPU, Ms::NumberOrArrayOrFunction)</code></pre><p>Set magnetic moment mu_s of the studied system. For example,</p><pre><code class="language-julia">   set_mu_s(sim, 8.6e5)</code></pre><p>or</p><pre><code class="language-julia">function circular_shape(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end
set_mu_s(sim, circular_shape)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/sim.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.init_m0" href="#JuMag.init_m0"><code>JuMag.init_m0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)</code></pre><p>Set the initial magnetization of the system. If <code>norm=false</code> the magnetization array will be not normalised. Examples:</p><pre><code class="language-julia">   init_m0(sim, (1,1,1))</code></pre><p>or</p><pre><code class="language-julia">   init_m0(sim, (1,1,1), norm=false)</code></pre><p>or</p><pre><code class="language-julia">   function uniform_m0(i,j,k,dx,dy,dz)
       return (0,0,1)
   end
   init_m0(sim, uniform_m0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L106-L126">source</a></section><section><div><pre><code class="language-none">init_m0(sim::AbstractSimGPU, m0::TupleOrArrayOrFunction; norm=true)</code></pre><p>Set the initial magnetization of the system. If <code>norm=false</code> the magnetization array will be not normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/cuda/sim.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.init_m0_random" href="#JuMag.init_m0_random"><code>JuMag.init_m0_random</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_m0_random(sim::MicroSim)</code></pre><p>Set the initial magnetization with random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/init_m.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.init_m0_skyrmion" href="#JuMag.init_m0_skyrmion"><code>JuMag.init_m0_skyrmion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_m0_skyrmion(sim::AbstractSim, center::Tuple, R::Float64; ratio=0.7, p=-1, c=1, type=&quot;B&quot;)</code></pre><p>Set the magnetization with skyrmions. Note that this function can be called mulitple times to add more skyrmons.</p><p>center :  the skyrmion center, should be a Tuple. For example, center = (50e-9,50e-9)</p><p>R : the skyrmion radius.</p><p>ratio : ratio=w/R where w is the width of domain wall. By default ratio = 0.7</p><p>p : polarity, +1 –&gt; core up; -1 –&gt; core down</p><p>c : chirality, +1 –&gt; clockwise; -1 –&gt; counter-clockwise</p><p>type : &quot;B&quot; or &quot;N&quot;, representing Bloch or Neel skyrmions.</p><p>For example:</p><pre><code class="language-julia">    init_m0_skyrmion(sim, (50e-9,50e-9), 2e-8, ratio=0.5, p=-1, c=1, type=&quot;B&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/init_m.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_exch" href="#JuMag.add_exch"><code>JuMag.add_exch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_exch(sim::AbstractSim, A::NumberOrArrayOrFunction; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L276-L280">source</a></section><section><div><pre><code class="language-none">add_exch(sim::AtomicSimGPU, J::Array; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system. The length of J should be equal to the length of neigbours.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/sim.jl#L45-L49">source</a></section><section><div><pre><code class="language-none">add_exch(sim::AtomicSimGPU, J::Number; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/sim.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_anis" href="#JuMag.add_anis"><code>JuMag.add_anis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy to the system, where the energy density is given by</p><div>\[E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L402-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_dmi" href="#JuMag.add_dmi"><code>JuMag.add_dmi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_dmi(sim::AbstractSim, D::Tuple{Real, Real, Real}; name=&quot;dmi&quot;)</code></pre><p>Add DMI to the system. Example:</p><pre><code class="language-julia">   add_dmi(sim, (1e-3, 1e-3, 0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L320-L328">source</a></section><section><div><pre><code class="language-none">add_dmi(sim::AbstractSim, D::Real; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add DMI to the system. <code>type</code> could be &quot;bulk&quot; or &quot;interfacial&quot; Examples:</p><pre><code class="language-julia">   add_dmi(sim, 1e-3, type=&quot;interfacial&quot;)</code></pre><p>or</p><pre><code class="language-julia">   add_dmi(sim, 1e-3, type=&quot;bulk&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L345-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_demag" href="#JuMag.add_demag"><code>JuMag.add_demag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_demag(sim::MicroSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0)</code></pre><p>Add Demag to the system. <code>Nx</code>, <code>Ny</code> and <code>Nz</code> can be used to describe the macro boundary conditions which means that the given mesh is repeated <code>2Nx+1</code>, <code>2Ny+1 and</code>2Nz+1<code>times in</code>x<code>,</code>y<code>and</code>z` direction, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_zeeman" href="#JuMag.add_zeeman"><code>JuMag.add_zeeman</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Add a static Zeeman energy to the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L142-L146">source</a></section><section><div><pre><code class="language-none">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=&quot;timezeeman&quot;)</code></pre><p>Add a time varying zeeman to system.</p><p>The input <code>ft</code> is a function of time <code>t</code> and its return value should be a tuple with length 3.</p><p>Example:</p><pre><code class="language-julia">  function time_fun(t)
    w = 2*pi*2.0e9
    return (sin(w*t), cos(w*t), 0)
  end

  function spatial_H(i, j, k, dx, dy, dz)
    H = 1e3
    if i&lt;=2
        return (H, H, 0)
    end
    return (0, 0, 0)
  end

  add_zeeman(sim, spatial_H, time_fun)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L197-L222">source</a></section><section><div><pre><code class="language-none">add_zeeman(sim::AbstractSimGPU, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Add a static Zeeman energy to the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/cuda/sim.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_exch_vector" href="#JuMag.add_exch_vector"><code>JuMag.add_exch_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_exch_vector(sim::AbstractSim, A::TupleOrArrayOrFunction; name=&quot;exch&quot;)</code></pre><p>Add a vector form exchange energy to the system. The exchange constant of 3 directions can be different. For example:</p><pre><code class="language-julia">add_exc_vector(sim, (2e-12,5e-12,0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L249-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_exch_kagome" href="#JuMag.add_exch_kagome"><code>JuMag.add_exch_kagome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_exch_kagome(sim::AtomicSimGPU, Jxy::Number, Jz::Number; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/sim.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.add_anis_kagome" href="#JuMag.add_anis_kagome"><code>JuMag.add_anis_kagome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_anis_kagome(sim::AtomicSimGPU, Ku::Float64; ax1=(-0.5,-sqrt(3)/2,0), ax2=(1,0,0), ax3=(-0.5,sqrt(3)/2,0), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy for kagome system, where the energy density is given by</p><div>\[E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/atomistic/sim.jl#L106-L114">source</a></section><section><div><pre><code class="language-none">add_anis_kagome(sim::MonteCarloNew, Ku::Float64)</code></pre><p>Add Anisotropy for kagome system, where the energy density is given by</p><div>\[    E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</div><p>and u is one of ax1=(-0.5,-sqrt(3)/2,0), ax2=(1,0,0) and ax3=(-0.5,sqrt(3)/2,0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/mc/mc.jl#L187-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.update_zeeman" href="#JuMag.update_zeeman"><code>JuMag.update_zeeman</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_zeeman(sim::AbstractSim, H0::Tuple; name=&quot;zeeman&quot;)</code></pre><p>Set the Zeeman field to H0 where H0 is TupleOrArrayOrFunction according to its name. For example,</p><pre><code class="language-julia">   add_zeeman(sim, (0,0,0), name=&quot;my_H&quot;)  #create a zeeman energy with field (0,0,0) A/m
   update_zeeman(sim, (0,0,1e5), name=&quot;my_H&quot;)  #change the field to (0,0,1e5) A/m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.update_anis" href="#JuMag.update_anis"><code>JuMag.update_anis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = &quot;anis&quot;)</code></pre><p>update anisotropy constant Ku according to its name.</p><p>Example:</p><pre><code class="language-julia">    mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9)
    sim = Sim(mesh)
    add_anis(sim, 3e4, axis = (0,0,1), name=&quot;K1&quot;)
    add_anis(sim, 1e5, axis = (1,0,0), name=&quot;K2&quot;)
    update_anis(sim, 5e4, name=&quot;K2&quot;)  #update anisotropy K2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.relax" href="#JuMag.relax"><code>JuMag.relax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relax(sim::AbstractSim; maxsteps=10000, stopping_dmdt=0.01, save_m_every = 10, save_ovf_every=-1, ovf_format = &quot;binary&quot;, ovf_folder=&quot;ovfs&quot;, save_vtk_every=-1, vtk_folder=&quot;vtks&quot;,fields::Array{String, 1} = String[])</code></pre><p>Relax the system using <code>LLG</code> or <code>SD</code> driver. The stop condition is determined by <code>stopping_dmdt</code>(both for <code>LLG</code> and <code>SD</code> drivers). Spins can be stored in ovfs or vtks. ovf format can be chosen in &quot;binary&quot;(float64),&quot;binary8&quot;(float64), &quot;binary4&quot;(float32), &quot;text&quot;</p><p>Fields can be stored in vtks by:</p><pre><code class="language-julia">relax(sim, save_vtk_every = 10, fields = [&quot;demag&quot;, &quot;exch&quot;, &quot;anis&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/sim.jl#L474-L485">source</a></section></article><h3 id="DataSaving-1"><a class="docs-heading-anchor" href="#DataSaving-1">DataSaving</a><a class="docs-heading-anchor-permalink" href="#DataSaving-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMag.save_m" href="#JuMag.save_m"><code>JuMag.save_m</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_m(sim::AbstractSim, fname::String; vtk::Bool = false, npy::Bool = false, vtk_folder = &quot;vtks&quot;)

If vtk = true, save spins to dir ./vtks/ in vtk format;
If npy = true, save spins to current directory in npy format;

Example:

```julia
    save_m(sim, sim.name, vtk = true, npy= true)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/vtk.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.save_vtk" href="#JuMag.save_vtk"><code>JuMag.save_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_vtk(sim::AbstractSim, fname::String; fields::Array{String, 1} = String[])</code></pre><p>Save magnetization or other fields to vtk.</p><pre><code class="language-julia">    save_vtk(sim, &quot;m&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/vtk.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.save_ovf" href="#JuMag.save_ovf"><code>JuMag.save_ovf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>save_ovf(sim::AbstractSim, fname::String; dataformat::String = &quot;text&quot;)</p><p>Save spins in format of ovf, which can be viewed by Muview. Dataformat could be &quot;text&quot;, &quot;binary4&quot; or &quot;binary8&quot;.</p><p>For example:</p><pre><code class="language-none">```julia
    save_ovf(sim, &quot;m0&quot;)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/ovf2.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMag.read_ovf" href="#JuMag.read_ovf"><code>JuMag.read_ovf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_ovf(sim, fname)

Initialize sim with an ovf file named of &quot;fname.ovf&quot;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/ovf2.jl#L177-L181">source</a></section><section><div><pre><code class="language-none">read_ovf(fname)

Load ovf file as OVF2 Type, where spin is stored in OVF2.data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/ovf2.jl#L237-L241">source</a></section></article><h3 id="Tools-1"><a class="docs-heading-anchor" href="#Tools-1">Tools</a><a class="docs-heading-anchor-permalink" href="#Tools-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuMag.ovf2vtk" href="#JuMag.ovf2vtk"><code>JuMag.ovf2vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ovf2vtk(ovf_name, vtk_name=nothing; point_data=false, box=noting)</code></pre><p>Convert ovf file to vtk format. The data will be saved to points if point_data == true otherwise the data will be saved to cells.</p><p>If box is not nothing, it should be a tuple. For instance, box = (nx1, nx2, ny1, ny2, nz1, nz2). In this case, the generated vtk only contains the spins inside the box (including the boundary).</p><pre><code class="language-julia">    ovf2vtk(&quot;my.ovf&quot;, &quot;test.vts&quot;)
    ovf2vtk(&quot;my.ovf&quot;, point_data=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ww1g11/JuMag.jl/blob/9e51c8b11f50db204895d68fe7064f1bc01953a3/src/vtk.jl#L92-L105">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../notes/">« Notes</a><a class="docs-footer-nextpage" href="../questions/">Questions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 April 2020 14:51">Monday 13 April 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
