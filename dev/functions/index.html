<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · JuMag.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMag.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">JuMag.jl</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../equations/">Implemented equations</a></li><li><a class="toctext" href="../notes/">Notes</a></li><li class="current"><a class="toctext" href>Function References</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function References</a></li></ul><a class="edit-page" href="https://github.com/ww1g11/JuMagDocs.jl/blob/master/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function References</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Function-References-1" href="#Function-References-1">Function References</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.FDMesh" href="#JuMag.FDMesh"><code>JuMag.FDMesh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=&quot;open&quot;)</code></pre><p>Create a FDMesh for given parameters. <code>pbc</code> could be any combination of &quot;x&quot;, &quot;y&quot; and &quot;z&quot;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.Sim" href="#JuMag.Sim"><code>JuMag.Sim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Sim(mesh::Mesh; driver=&quot;LLG&quot;, name=&quot;dyn&quot;, integrator=&quot;Dopri5&quot;)</code></pre><p>Create a simulation instance for given mesh.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.NumberOrArrayOrFunction" href="#JuMag.NumberOrArrayOrFunction"><code>JuMag.NumberOrArrayOrFunction</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NumberOrArrayOrFunction</code></pre><p>In Micromagnetics, typical parameters such as saturation magnetization <code>Ms</code> and exchange stiffness constant <code>A</code> are constant. However, there are many cases that a spatial <code>Ms</code> is needed. For instance, if the simulated system is a circular disk the Ms in the corners should be set to zero. If the simulated system contains mutiple materials, the exchange constant <code>A</code> should be spatial as well. The Union <code>NumberOrArrayOrFunction</code> is designed to deal with such situations. As indicated from its name, it means that the input parameter could be a number or an array or a function:</p><ul><li><p>Number: should be Real.</p></li><li><p>Array: the length of the array should be <code>N</code> where <code>N</code> is the total spin number of the system.</p></li><li><p>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> where <code>i,j,k</code> is the cell index and <code>dx,dy,dz</code> is the cellsize. The return value of the function should be a real number. For example,</p><pre><code class="language-julia">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end</code></pre></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.TupleOrArrayOrFunction" href="#JuMag.TupleOrArrayOrFunction"><code>JuMag.TupleOrArrayOrFunction</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">TupleOrArrayOrFunction</code></pre><p>Similar to <code>NumberOrArrayOrFunction</code>, <code>TupleOrArrayOrFunction</code> means that the input parameter could be a tuple or an array or a function:</p><ul><li>Tuple: should be Real with length 3. For example, <code>(0,0,1e5)</code>.</li><li>Array: the length of the array should be <code>3N</code> where <code>N</code> is the total spin number of the system.</li><li>Function: the parameter of the function should be <code>(i,j,k,dx,dy,dz)</code> and the return value should be a tuple with length 3. For example,<pre><code class="language-julia">function uniform_m0(i,j,k,dx,dy,dz)
    return (0,0,1)
end</code></pre></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.set_Ms" href="#JuMag.set_Ms"><code>JuMag.set_Ms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)</code></pre><p>Set the saturation magnetization Ms of the studied system. For example,</p><pre><code class="language-julia">   set_Ms(sim, 8.6e5)</code></pre><p>or</p><pre><code class="language-julia">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end
set_Ms(sim, circular_Ms)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.init_m0" href="#JuMag.init_m0"><code>JuMag.init_m0</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)</code></pre><p>Set the initial magnetization of the system. If <code>norm=false</code> the magnetization array will be not normalised. Examples:</p><pre><code class="language-julia">   init_m0(sim, (1,1,1))</code></pre><p>or</p><pre><code class="language-julia">   init_m0(sim, (1,1,1), norm=false)</code></pre><p>or</p><pre><code class="language-julia">   function uniform_m0(i,j,k,dx,dy,dz)
       return (0,0,1)
   end
   init_m0(sim, uniform_m0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.add_exch" href="#JuMag.add_exch"><code>JuMag.add_exch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_exch(sim::AbstractSim, A::NumberOrArrayOrFunction; name=&quot;exch&quot;)</code></pre><p>Add exchange energy to the system.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.add_anis" href="#JuMag.add_anis"><code>JuMag.add_anis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=&quot;anis&quot;)</code></pre><p>Add Anisotropy to the system, where the energy density is given by</p><div>\[E_\mathrm{anis} = - K_{u} (\vec{m} \cdot \hat{u})^2\]</div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.add_dmi" href="#JuMag.add_dmi"><code>JuMag.add_dmi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_dmi(sim::AbstractSim, D::Tuple{Real, Real, Real}; name=&quot;dmi&quot;)</code></pre><p>Add DMI to the system. Example:</p><pre><code class="language-julia">   add_dmi(sim, (1e-3, 1e-3, 0))</code></pre></div></div><div><div><pre><code class="language-none">add_dmi(sim::AbstractSim, D::Real; name=&quot;dmi&quot;, type=&quot;bulk&quot;)</code></pre><p>Add DMI to the system. <code>type</code> could be &quot;bulk&quot; or &quot;interfacial&quot; Examples:</p><pre><code class="language-julia">   add_dmi(sim, 1e-3, type=&quot;interfacial&quot;)</code></pre><p>or</p><pre><code class="language-julia">   add_dmi(sim, 1e-3, type=&quot;bulk&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.add_demag" href="#JuMag.add_demag"><code>JuMag.add_demag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_demag(sim::MicroSim; name=&quot;demag&quot;, Nx=0, Ny=0, Nz=0)</code></pre><p>Add Demag to the system. <code>Nx</code>, <code>Ny</code> and <code>Nz</code> can be used to describe the macro boundary conditions which means that the given mesh is repeated <code>2Nx+1</code>, <code>2Ny+1 and</code>2Nz+1<code>times in</code>x<code>,</code>y<code>and</code>z` direction, respectively.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.add_zeeman" href="#JuMag.add_zeeman"><code>JuMag.add_zeeman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=&quot;zeeman&quot;)</code></pre><p>Add a static Zeeman energy to the simulation.</p></div></div><div><div><pre><code class="language-none">add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=&quot;timezeeman&quot;)</code></pre><p>Add a time varying zeeman to system.</p><p>The input <code>ft</code> is a function of time <code>t</code> and its return value should be a tuple with length 3.</p><p>Example:</p><pre><code class="language-julia">  function time_fun(t)
    w = 2*pi*2.0e9
    return (sin(w*t), cos(w*t), 0)
  end

  function spatial_H(i, j, k, dx, dy, dz)
    H = 1e3
    if i&lt;=2
        return (H, H, 0)
    end
    return (0, 0, 0)
  end

  add_zeeman(sim, spatial_H, time_fun)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.update_zeeman" href="#JuMag.update_zeeman"><code>JuMag.update_zeeman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_zeeman(sim::AbstractSim, H0::Tuple; name=&quot;zeeman&quot;)</code></pre><p>Set the external field of Zeeman z to H0 where H0 is TupleOrArrayOrFunction. For example,</p><pre><code class="language-julia">   add_zeeman(sim, (0,0,0)) #create a zeeman energy with field (0,0,0) A/m
   update_zeeman(sim, (0,0,1e5)) #change the field to (0,0,1e5) A/m</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.update_anis" href="#JuMag.update_anis"><code>JuMag.update_anis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = &quot;anis&quot;)</code></pre><p>Replace the value of Anisotropy with Ku Example:</p><p><code>julia mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9) sim = Sim(mesh) add_anis(sim,3e4,axis = (0,0,1)) update_anis(sim, 5e4)</code>`</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMag.relax" href="#JuMag.relax"><code>JuMag.relax</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">relax(sim::AbstractSim; maxsteps=10000, stopping_dmdt=0.01, stopping_torque=0.1, save_m_every = 10, save_ovf_every=-1, ovf_format = &quot;binary&quot;, ovf_folder=&quot;ovfs&quot;, save_vtk_every=-1, vtk_folder=&quot;vtks&quot;,fields::Array{String, 1} = String[])</code></pre><p>Relax the system using <code>LLG</code> or <code>SD</code> driver. The stop condition is determined by either <code>stopping_dmdt</code>(for <code>LLG</code>) or <code>stopping_torque</code>(for <code>SD</code>). Spins can be stored in ovfs or vtks. ovf format can be chosen in &quot;binary&quot;(float64),&quot;binary8&quot;(float64), &quot;binary4&quot;(float32), &quot;text&quot;</p><p>Fields can be stored in vtks by:</p><pre><code class="language-julia">relax(sim,save_vtk_every = 10,fields = [&quot;demag&quot;,&quot;exch&quot;,&quot;anis&quot;])</code></pre></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>save_m</code>. Check Documenter&#39;s build log for details.</p></div></div><footer><hr/><a class="previous" href="../notes/"><span class="direction">Previous</span><span class="title">Notes</span></a></footer></article></body></html>
