var documenterSearchIndex = {"docs":
[{"location":"notes/#Notes-1","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"notes/#Reducing-the-startup-time-1","page":"Notes","title":"Reducing the startup time","text":"","category":"section"},{"location":"notes/#","page":"Notes","title":"Notes","text":"Julia is a dynamically-typed language, so the input script will be compiled when we start a simulation. However, the typical startup time in our case ranges from 1s to 30s depends on the complexity of the problem. It is painful especially if we run the simulation using GPU. Luckily, we can compile our package using PackageCompiler.jl:","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"using PackageCompiler\ncompile_incremental(:JuMag)","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"After finishing the compilation, a dyn.so file will be generated. If we start julia using julia -J /path/to/dyn.so the stratup time will be ignorable.","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"Note: If you got an error similar to that shown at https://github.com/JuliaLang/PackageCompiler.jl/issues/184, using dev PackageCompiler may solve the issue.","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"If other errors appear, it is better to figure out which package is failed","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"compile_incremental(:FFTW, :CUDAdrv, :CUDAnative, :CuArrays, force=false)","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"and remove that package from deps in Project.toml. For example, if CuArrays fails, comment the line","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"#CuArrays = \"3a865a2d-5b23-5a0f-bc46-62713ec82fae\"","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"may solve the problem.","category":"page"},{"location":"notes/#LLG-equation-with-Zhang-Li-extension-1","page":"Notes","title":"LLG equation with Zhang-Li extension","text":"","category":"section"},{"location":"notes/#","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t = - gamma vecm times vecH + alpha vecm times  fracpartial vecmpartial t   + u_0 (vecj_s cdot nabla) vecm - beta u_0 vecmtimes (vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"u_0=fracp g mu_B2 e M_s=fracp g mu_B a^32 e mu_s","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"and mu_B=ehbar(2m) is the Bohr magneton. In LL form","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"(1+alpha^2)fracpartial vecmpartial t = - gamma vecm times vecH - alpha gamma vecm times (vecm times vecH) + (1+alphabeta) u_0 vectau - (beta-alpha) u_0 (vecmtimes vectau)","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"where vectau=(vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"Note that","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"u_0 (vecj_s cdot nabla) vecm=  - u_0 vecmtimesvecmtimes (vecj_s cdot nabla)vecm","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"so this torque is damping-like torque and the last torque is field-like torque. Therefore, we rewrite the LLG equation in the form","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t =\nF(vecm)\ntimes vecm","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"F(vecm) = frac1(1+alpha^2)\ngamma vecH + u_0 (beta-alpha)vectau+\nfrac1(1+alpha^2)vecm times alpha gamma\n  vecH + u_0 (1+alphabeta) vectau","category":"page"},{"location":"notes/#Cayley-transformation-1","page":"Notes","title":"Cayley transformation","text":"","category":"section"},{"location":"notes/#","page":"Notes","title":"Notes","text":"The LLG equation can be cast into","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"fracpartial vecmpartial t = hatF(vecm) cdot vecm","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"where the operator \\hat{} is defined as","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"hatx = left( beginmatrix\n  0  -x_3  x_2 \n  x_3  0  -x_1 \n  -x_2  x_1  0\n endmatrix right)","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"Using the Cayley transfromation, the LLG equation can be written as","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"fracpartial Omegapartial t = F - frac12 Omega F\n- frac14 Omega F Omega","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"where","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"Omega = hatomega","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"So one has","category":"page"},{"location":"notes/#","page":"Notes","title":"Notes","text":"fracpartial vecomegapartial t = vecF - frac12\n(omega times vecF)\n+ frac14 (omega cdot vecF) vecomega","category":"page"},{"location":"functions/#Function-References-1","page":"Function References","title":"Function References","text":"","category":"section"},{"location":"functions/#","page":"Function References","title":"Function References","text":"FDMesh\nSim\nJuMag.NumberOrArrayOrFunction\nJuMag.TupleOrArrayOrFunction\nset_Ms\ninit_m0\nadd_exch\nadd_anis\nadd_dmi\nadd_demag\nadd_zeeman\nupdate_zeeman\nupdate_anis\nrelax\nsave_m\nsave_vtk\nsave_ovf\nread_ovf","category":"page"},{"location":"functions/#JuMag.FDMesh","page":"Function References","title":"JuMag.FDMesh","text":"FDMesh(;dx=1e-9, dy=1e-9, dz=1e-9, nx=1, ny=1, nz=1, pbc=\"open\")\n\nCreate a FDMesh for given parameters. pbc could be any combination of \"x\", \"y\" and \"z\".\n\n\n\n\n\n","category":"type"},{"location":"functions/#JuMag.Sim","page":"Function References","title":"JuMag.Sim","text":"Sim(mesh::Mesh; driver=\"LLG\", name=\"dyn\", integrator=\"Dopri5\")\n\nCreate a simulation instance for given mesh.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.NumberOrArrayOrFunction","page":"Function References","title":"JuMag.NumberOrArrayOrFunction","text":"NumberOrArrayOrFunction\n\nIn Micromagnetics, typical parameters such as saturation magnetization Ms and exchange stiffness constant A are constant. However, there are many cases that a spatial Ms is needed. For instance, if the simulated system is a circular disk the Ms in the corners should be set to zero. If the simulated system contains mutiple materials, the exchange constant A should be spatial as well. The Union NumberOrArrayOrFunction is designed to deal with such situations. As indicated from its name, it means that the input parameter could be a number or an array or a function:\n\nNumber: should be Real.\nArray: the length of the array should be N where N is the total spin number of the system.\nFunction: the parameter of the function should be (i,j,k,dx,dy,dz) where i,j,k is the cell index and dx,dy,dz is the cellsize. The return value of the function should be a real number. For example,\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend\n\n\n\n\n\n","category":"constant"},{"location":"functions/#JuMag.TupleOrArrayOrFunction","page":"Function References","title":"JuMag.TupleOrArrayOrFunction","text":"TupleOrArrayOrFunction\n\nSimilar to NumberOrArrayOrFunction, TupleOrArrayOrFunction means that the input parameter could be a tuple or an array or a function:\n\nTuple: should be Real with length 3. For example, (0,0,1e5).\nArray: the length of the array should be 3N where N is the total spin number of the system.\nFunction: the parameter of the function should be (i,j,k,dx,dy,dz) and the return value should be a tuple with length 3. For example,\nfunction uniform_m0(i,j,k,dx,dy,dz)\n    return (0,0,1)\nend\n\n\n\n\n\n","category":"constant"},{"location":"functions/#JuMag.set_Ms","page":"Function References","title":"JuMag.set_Ms","text":"set_Ms(sim::MicroSim, Ms::NumberOrArrayOrFunction)\n\nSet the saturation magnetization Ms of the studied system. For example,\n\n   set_Ms(sim, 8.6e5)\n\nor\n\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend\nset_Ms(sim, circular_Ms)\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.init_m0","page":"Function References","title":"JuMag.init_m0","text":"init_m0(sim::MicroSim, m0::TupleOrArrayOrFunction; norm=true)\n\nSet the initial magnetization of the system. If norm=false the magnetization array will be not normalised. Examples:\n\n   init_m0(sim, (1,1,1))\n\nor\n\n   init_m0(sim, (1,1,1), norm=false)\n\nor\n\n   function uniform_m0(i,j,k,dx,dy,dz)\n       return (0,0,1)\n   end\n   init_m0(sim, uniform_m0)\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.add_exch","page":"Function References","title":"JuMag.add_exch","text":"add_exch(sim::AbstractSim, A::NumberOrArrayOrFunction; name=\"exch\")\n\nAdd exchange energy to the system.\n\n\n\n\n\nadd_exch(sim::AtomicSim, Js::Array{Float64, 1}; name=\"exch\")\n\nAdd exchange energy to the system.\n\n\n\n\n\nadd_exch(sim::AtomicSim, J::Number; name=\"exch\")\n\nAdd exchange energy to the system.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.add_anis","page":"Function References","title":"JuMag.add_anis","text":"add_anis(sim::AbstractSim, Ku::NumberOrArrayOrFunction; axis=(0,0,1), name=\"anis\")\n\nAdd Anisotropy to the system, where the energy density is given by\n\nE_mathrmanis = - K_u (vecm cdot hatu)^2\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.add_dmi","page":"Function References","title":"JuMag.add_dmi","text":"add_dmi(sim::AbstractSim, D::Tuple{Real, Real, Real}; name=\"dmi\")\n\nAdd DMI to the system. Example:\n\n   add_dmi(sim, (1e-3, 1e-3, 0))\n\n\n\n\n\nadd_dmi(sim::AbstractSim, D::Real; name=\"dmi\", type=\"bulk\")\n\nAdd DMI to the system. type could be \"bulk\" or \"interfacial\" Examples:\n\n   add_dmi(sim, 1e-3, type=\"interfacial\")\n\nor\n\n   add_dmi(sim, 1e-3, type=\"bulk\")\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.add_demag","page":"Function References","title":"JuMag.add_demag","text":"add_demag(sim::MicroSim; name=\"demag\", Nx=0, Ny=0, Nz=0)\n\nAdd Demag to the system. Nx, Ny and Nz can be used to describe the macro boundary conditions which means that the given mesh is repeated 2Nx+1, 2Ny+1 and2Nz+1times inx,yandz` direction, respectively.\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.add_zeeman","page":"Function References","title":"JuMag.add_zeeman","text":"add_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction; name=\"zeeman\")\n\nAdd a static Zeeman energy to the simulation.\n\n\n\n\n\nadd_zeeman(sim::AbstractSim, H0::TupleOrArrayOrFunction, ft::Function; name=\"timezeeman\")\n\nAdd a time varying zeeman to system.\n\nThe input ft is a function of time t and its return value should be a tuple with length 3.\n\nExample:\n\n  function time_fun(t)\n    w = 2*pi*2.0e9\n    return (sin(w*t), cos(w*t), 0)\n  end\n\n  function spatial_H(i, j, k, dx, dy, dz)\n    H = 1e3\n    if i<=2\n        return (H, H, 0)\n    end\n    return (0, 0, 0)\n  end\n\n  add_zeeman(sim, spatial_H, time_fun)\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.update_zeeman","page":"Function References","title":"JuMag.update_zeeman","text":"update_zeeman(sim::AbstractSim, H0::Tuple; name=\"zeeman\")\n\nSet the Zeeman field to H0 where H0 is TupleOrArrayOrFunction according to its name. For example,\n\n   add_zeeman(sim, (0,0,0), name=\"my_H\")  #create a zeeman energy with field (0,0,0) A/m\n   update_zeeman(sim, (0,0,1e5), name=\"my_H\")  #change the field to (0,0,1e5) A/m\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.update_anis","page":"Function References","title":"JuMag.update_anis","text":"update_anis(sim::MicroSim, Ku::NumberOrArrayOrFunction; name = \"anis\")\n\nupdate anisotropy constant Ku according to its name.\n\nExample:\n\njulia     mesh = FDMesh(nx=200, ny=200, nz=12, dx=5e-9, dy=5e-9, dz=5e-9)     sim = Sim(mesh)     add_anis(sim, 3e4, axis = (0,0,1), name=\"K1\")     add_anis(sim, 1e5, axis = (1,0,0), name=\"K2\")     update_anis(sim, 5e4, name=\"K2\")  #update anisotropy K2`\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.relax","page":"Function References","title":"JuMag.relax","text":"relax(sim::AbstractSim; maxsteps=10000, stopping_dmdt=0.01, save_m_every = 10, save_ovf_every=-1, ovf_format = \"binary\", ovf_folder=\"ovfs\", save_vtk_every=-1, vtk_folder=\"vtks\",fields::Array{String, 1} = String[])\n\nRelax the system using LLG or SD driver. The stop condition is determined by stopping_dmdt(both for LLG and SD drivers). Spins can be stored in ovfs or vtks. ovf format can be chosen in \"binary\"(float64),\"binary8\"(float64), \"binary4\"(float32), \"text\"\n\nFields can be stored in vtks by:\n\nrelax(sim, save_vtk_every = 10, fields = [\"demag\", \"exch\", \"anis\"])\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.save_m","page":"Function References","title":"JuMag.save_m","text":"save_m(sim::AbstractSim, fname::String; vtk::Bool = false, npy::Bool = false, vtk_folder = \"vtks\")\n\nIf vtk = true, save spins to dir ./vtks/ in vtk format;\nIf npy = true, save spins to current directory in npy format;\n\nExample:\n\n```julia\n    save_m(sim, sim.name, vtk = true, npy= true)\n```\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.save_vtk","page":"Function References","title":"JuMag.save_vtk","text":"save_vtk(sim::AbstractSim, fname::String; fields::Array{String, 1} = String[])\n\nSave magnetization or other fields to vtk.\n\n    save_vtk(sim, \"m\")\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.save_ovf","page":"Function References","title":"JuMag.save_ovf","text":"save_ovf(sim::AbstractSim, fname::String; dataformat::String = \"text\")\n\nSave spins in format of ovf, which can be viewed by Muview. Dataformat could be \"text\", \"binary4\" or \"binary8\".\n\nFor example:\n\n```julia\n    save_ovf(sim, \"m0\")\n```\n\n\n\n\n\n","category":"function"},{"location":"functions/#JuMag.read_ovf","page":"Function References","title":"JuMag.read_ovf","text":"read_ovf(sim, fname)\n\nInitialize sim with an ovf file named of \"fname.ovf\".\n\n\n\n\n\nread_ovf(fname)\n\nLoad ovf file as OVF2 Type, where spin is stored in OVF2.data\n\n\n\n\n\n","category":"function"},{"location":"equations/#Implemented-equations-1","page":"Implemented equations","title":"Implemented equations","text":"","category":"section"},{"location":"equations/#Energies-and-effective-field-1","page":"Implemented equations","title":"Energies and effective field","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"In micromagnetics, the effective field can be computed from the total micromagnetic energy","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"vecH_mathrmeff=-frac1mu_0 M_s fracdelta Edelta vecm","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The typical energy terms are","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Exchange energy\nE_mathrmex = int_V A (nabla vecm)^2 mathrmdV\nwhere (nabla vecm)^2=left(nabla m_xright)^2+left(nabla m_yright)^2+left(nabla m_zright)^2. So the corresponding effective field is\nvecH_mathrmex=frac2 Amu_0 M_s nabla^2 vecm\nZeeman energy\nE_mathrmex = -  mu_0 int_V  vecH cdot vecM mathrmdV\nas expected, the effective field is vecH.\nAnisotropy\nThe uniaxial anisotropy energy is given by\nE_mathrmanis = -int_V K_u (vecm cdot hatu)^2  dV\nfrom which the effective field can be computed as\nvecH_mathrman=frac2 K_umu_0 M_sleft(vecm cdot haturight) hatu\nCubic Anisotropy\nThe cubic anisotropy energy is given by\nE_mathrmcubic = -int_V K_c (m_x^4 + m_y^4 + m_z^4)  dV\nand thus the corresponding effective field reads\nvecH_mathrmcubic= frac4 K_cmu_0 M_s  \nleft( m_x^3 mathbfe_x + m_y^3 mathbfe_y + m_z^3 mathbfe_z right)\nBulk DMI energy The Bulk DMI energy reads\nE_mathrmdmi = int_V D vecm cdot (nabla times vecm)  mathrmdV\nso the effective field is\nvecH_mathrmD=-frac2 Dmu_0 M_s(nabla times vecm)\nMagnetostatic energy\nE_mathrmd=-fracmu_02 int_V vecH_mathrmd(mathbfr) cdot\nvecM(mathbfr) d V\nvecH_mathrmd(mathbfr)=frac14 pileft(int_V rho_mleft(mathbfr^primeright) fracmathbfr-mathbfr^primeleftmathbfr-mathbfr^primeright^3 mathrmd^3 r^prime+int_S sigma_mleft(mathbfr^primeright) fracmathbfr-mathbfr^primeleftmathbfr-mathbfr^primeright^3 mathrmd^2 r^primeright)","category":"page"},{"location":"equations/#LLG-equation-1","page":"Implemented equations","title":"LLG equation","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The LLG equation is written as","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"fracpartial vecmpartial t = - gamma vecm times vecH + alpha vecm times  fracpartial vecmpartial t","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"and the corresponding LL form is given by","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"(1+alpha^2)fracpartial vecmpartial t = - gamma vecm times vecH - alpha gamma vecm times (vecm times vecH)","category":"page"},{"location":"equations/#LLG-equation-with-extensions-1","page":"Implemented equations","title":"LLG equation with extensions","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"For the driver LLG_STT_CPP the implemented equations is","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"fracpartial vecmpartial t = - gamma vecm times vecH + alpha vecm times  fracpartial vecmpartial t\n+ (vecu cdot nabla) vecm - beta vecmtimes (vecu cdot nabla)vecm - a_J vecm times (vecm times vecp)\n - eta a_J vecm times vecp","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The simulation related to spin transfer torques (in-plane and current-perpendicular-to-plane) and the spin orbit torques can use the LLG_STT_CPP driver.","category":"page"},{"location":"equations/#Steepest-descent-method-1","page":"Implemented equations","title":"Steepest descent method","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"We provide a steepest descent energy minimization method for a complicated system, which is of the form","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"x_k+1 = x_k + alpha_k d_k","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"d_k = - nabla f(x_k)","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"And for the micromagnetics, we have","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathbfm_k+1 = mathbfm_k - tau_k mathbfm_k  times (mathbfm_k times mathbfH_mathrmeff)","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"In practice, we use the following update rule to keep the magnetization vector normalized.","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"boldsymbolm_k+1=boldsymbolm_k-tau_k fracboldsymbolm_k+boldsymbolm_k+12 timesleft(boldsymbolm_k times boldsymbolH_mathrmeffleft(boldsymbolm_kright)right)","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"boldsymbolm_k+1^2 = boldsymbolm_k^2","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"From the equation we have:","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"(1+fractau_k^24 boldsymbolf_k^2)mathbfm_k+1 =\n(1-fractau_k^24 boldsymbolf_k^2)mathbfm_k -  tau_k mathbfg_k","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"beginaligned\nmathbff_k = mathbfm_k times mathbfH_mathrmeff\nboldsymbolg_k =boldsymbolm_k timesleft(boldsymbolm_k times boldsymbolH_mathrmeffright)\nendaligned","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The step size tau_k can be computed by","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"tau_k^1=fracsum_i boldsymbols_k-1^i cdot boldsymbols_k-1^isum_i boldsymbols_k-1^i cdot boldsymboly_k-1^i quad quad tau_k^2=fracsum_i boldsymbols_k-1^i cdot boldsymboly_k-1^isum_i boldsymboly_k-1^i cdot boldsymboly_k-1^i","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"beginaligned  boldsymbols_k-1 =boldsymbolm_k-boldsymbolm_k-1  boldsymboly_k-1 =boldsymbolg_k-boldsymbolg_k-1 endaligned","category":"page"},{"location":"equations/#Monte-Carlo-Simulation-1","page":"Implemented equations","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"For cubic mesh, the implemented energy reads","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathcalH = - J sum_langle langle i jrangle rangle vecm_i cdot vecm_j\n+sum_langle langle i j rangle rangle   vecD_i j cdotleft(vecm_i times vecm_jright)\n- K sum_ileft(vecu cdot vecm_iright)^2 - sum_i vecH cdot vecm_i","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where vecm_i is unit vector of the classical spin at site i.","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"For triangular mesh (2D), the system energy reads","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"H= sum_langle i jrangle  vecD_i j cdotleft(vecS_i times vecS_jright)\n-J sum_langle i jrangle vecS_i cdot vecS_j- lambda sum_langle i jrangle S_i^z S_j^z\n-K sum_ileft(S_i^zright)^2","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"vecD_i j = D hatz times hatr_ij  + D_z^j hatz","category":"page"},{"location":"equations/#NEB-(Nudged-elastic-band)-1","page":"Implemented equations","title":"NEB (Nudged elastic band)","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"NEB is a chain method to find the MEP (minimum energy path) between two states. To start, we need to construct a chain including several images (each image is a copy of the magnetization) and then relax the system. Two ends images that corresponding to the initial and final states will be pinned as they are the energy states given by the users. The system contain all free images will be relaxed to reduce the total energy, which is very similar to the case that relaxing the magnetic system using LLG equation if one disables the precession term. One significant difference is that the effective field in LLG equation is the functional derivative of the system energy with respect to magnetization while in NEB the effective field of image n should also contain the influence of its neighbours (i.e., the images n-1 and n+1). This influence is described by the so-called tangents: only the perpendicaular part of the effective field is kept when relaxing the whole system.","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Assume that the whole system has N images","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathbfZ = mathbfY_1 mathbfY_2  mathbfY_N","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathbfY_i = m_1x m_1y m_1z  m_nx m_ny m_nz","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"each image has n spins. To relax the system, we could solve the equation","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"fracmathbfY_ipartial t = - mathbfY_i times (mathbfY_i times mathbfG_i)","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where mathbfG_i is effective field that can be computed as","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathbfY_i = mathbfH_i - (mathbfH_i cdot mathbft_i) mathbft_i +  mathbfF_i","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The mathbfH_i is the normal micromagnetic effective field, mathbft_i is the tangent and mathbfF_i is a force that can be used to adjust the distance between images.","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":" mathbfF_i = k (mathbfY_i+1-mathbfY_i-mathbfY_i-mathbfY_i-1) mathbft_i","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The distance bewteen images mathbfY_i and mathbfY_j is defined as","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":" L = left  sum_k (L_k^ij)^2 right  ^12","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where L_k^ij is the geodesic distance of point k that can be computed using Vincenty's formula.","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The tangents can be computed as follows","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathbft_i^+ =  mathbfY_i+1-mathbfY_i\nmathbft_i^- =  mathbfY_i-mathbfY_i-1","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"The detailed equations can be found @ [Journal of Chemical Physics 113, 22 (2000)] and [Computer Physics Communications 196 (2015) 335–347].","category":"page"},{"location":"equations/#Eigenvalue-Method-1","page":"Implemented equations","title":"Eigenvalue Method","text":"","category":"section"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Micromagnetic system and the corresponding atomistic model are the classical system. The resonance frequencies and the spatial resonance modes can be obtained using the eigenvalue method. In JuMag, we implemented a simple eigenvalue method for the following Hamiltonian of the atomistic model","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"mathcalH = -J sum_langle i jrangle vecm_i cdot vecm_j + sum_langle i jrangle  vecD_i j cdotleft(vecm_i times vecm_jright) - K sum_ileft(m_i^zright)^2 - mu_s vecm_i cdot vecH","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"For a given ground state or metastable spin configuration","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"vecm_0=(sintheta cos phi sintheta sin phi costheta)^T","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"one can construct a local coordinate system such that","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"vecm = w vecm_0 + u vece_theta + v  vece_phi","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where vece_theta =(cos theta cos phi costheta sinphi-sin theta)^T and vece_phi=(-sin phi cosphi0)^T. In matrix form,","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"beginbmatrix\nm_x  m_y  m_z\n endbmatrix =\n beginbmatrix\n cos phi cos theta  -sin phi  sin theta cos phi \n sin phi cos theta   cos phi  sin theta sin phi \n -sin theta  0   cos theta \n endbmatrix\n  beginbmatrix\n u  v  w\n endbmatrix","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Under this transformation, the unperturbed spin configuration vecm_0 corresponds to u=0 v=0 and w=1. In this local coordinate, the effective fields are given by","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"vecH_mathrmeff = - frac1mu_s fracpartial mathcalHpartial vecm\n= - frac1mu_sleft(  fracpartial mathcalHpartial w vecm_0 +\nfracpartial mathcalHpartial u vece_theta + fracpartial mathcalHpartial v vece_phi right)","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Substituting the effective fields into the LLG equation, we obtain for the case that alpha=0","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"begineqnarray\ndotu = -gamma (- w H_v + v H_w)\ndotv = -gamma ( w H_u - u H_w)\nendeqnarray","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where H_w, H_u and H_v are effective fields along vecm_0, vece_theta and vece_phi, respectively. To linearize the LLG equation, we assume u ll 1, v ll 1 and thus w approx 1- (12)(u^2+v^2). Moreover, we look for the solutions such that u=tildeue^-iomega t and v=tildeve^-iomega t. Therefore, we arrive at","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"begineqnarray\n -i omega mu_s  tildeu  =  gamma (tildeh_v - tildev tildeH_w)  \n-i omega mu_s tildev  =  - gamma (tildeh_u-tildeu tildeH_w)\nendeqnarray","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where we have ignored the higher-order terms. In addition, the above equation can be rewritten in a matrix form~\\cite{Lin2014a}","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"fraci omega mu_sgamma  \nbeginbmatrix\nvecu  vecv\n endbmatrix = mathbfA  \n beginbmatrix\nvecu  vecv\n endbmatrix","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"where we have introduced two vectors vecu=(tildeu_1 tildeu_2  tildeu_n)^T and vecv=(tildev_1 tildev_2  tildev_n)^T. Therefore, the normal modes of the system can be obtained through solving the eigenvalues of the matrix mathbfA. The eigenvalues are pure imaginary numbers since omega is real. The related effective fields are given by","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"begineqnarray\ntildeH_w = -(partial mathcalH^(0)partial w) big_w=1 \ntildeh_u = -(partial mathcalH^(2)partial u) big_w=1 u=tildeu v=tildev \ntildeh_v = -(partial mathcalH^(2)partial v) big_w=1 u=tildeu v=tildev \nendeqnarray","category":"page"},{"location":"equations/#","page":"Implemented equations","title":"Implemented equations","text":"Exchange interaction\nbegineqnarray\ntildeH^mathrmex_w i = J  sum_j left  cos theta_i cos theta_j + sin theta_i sin theta_j  cos(phi_i-phi_j) right\ntildeh^mathrmex_u i =  J sum_j left  tildeu_j cos(phi_i-phi_j) cos theta_i cos theta_j + tildeu_j sin theta_i sin theta_j + tildev_j costheta_i sin (phi_i - phi_j)  right \ntildeh^mathrman_v i =   J sum_j left   -tildeu_j costheta_j sin (phi_i - phi_j) + tildev_j cos(phi_i-phi_j)  right\nendeqnarray\nDMI\nbegingather\nbeginsplit\ntildeH^mathrmdmi_w i =  sum_j in X D_ij  left(  sin theta_j sin phi_j cos theta_i - sin theta_i sin phi_i cos theta_j right) + \n   sum_j in Y D_ij  left(  sin theta_i cos phi_i cos theta_j - sin theta_j cos phi_j cos theta_i  right) + \n   sum_j in Z D_ij   left   sin theta_i sin theta_j sin(phi_i-phi_j) right\nendsplit\nendgather\nwhere D_ij=Dmathrmsgn(j-i) with mathrmsgn(x) the sign function. The sets X, Y and Z represent the neighbours of site i in x-, y- and z-axis. Meanwhile, tildeh^mathrmdmi_u i and tildeh^mathrmdmi_v i are given by\nbegineqnarray\ntildeh^mathrmdmi_u i =    sum_j in X D_ij left(\ntildeu_j sin theta_j sin phi_i cos theta_i - tildeu_j sin theta_i sin phi_j cos theta_j - tildev_j sin theta_i cosphi_j right) +\nsum_jin Y D_ij left (tildeu_j sin theta_i cos phi_j cos theta_j - tildeu_j sin theta_j cos phi_i cos theta_i - tildev_j sin theta_i sinphi_j  right) + \nsum_jin Z D_ij cos theta_i  left  tildeu_j  cos theta_j sin(phi_i- phi_j) -tildev_j cos(phi_i-phi_j)  right \ntildeh^mathrmdmi_v i = sum_j in X D_ij  tildeu_j sin theta_j cosphi_i + textstyle sum_j in Y D_ij tildev_j sin theta_j  sinphi_i + \n                sum_j in Z D_ij left tildeu_j  cos theta_j  cos(phi_i -phi_j) + tildev_j sin (phi_i-phi_j) right\nendeqnarray\nAnisotropy For anisotropies with mathcalH_an = - sum_i (K_x m_xi^2 + K_z m_zi^2), these fields are given by\nbegineqnarray\ntildeH^mathrman_w i = 2K_xcos^2 phi_i sin^2 theta_i +  2K_z cos^2 theta_i \ntildeh^mathrman_u i =  2K_x cos phi_i cos theta_i (tildeu_i cosphi_i cos theta_i - tildev_i sinphi_i) +2 K_z tildeu_i sin^2theta_i \ntildeh^mathrman_v i = 2K_x sin phi_i (-tildeu_i cosphi_i cos theta_i + tildev_i sinphi_i )\nendeqnarray\nZeeman Field For a static external field vecH=(H_x H_y H_z), one obtains tildeh_u = tildeh_v = 0 and tildeH^a_w i = H_z cos theta_i + H_x cos phi_i sin theta_i + H_y sin phi_i sin theta_i.","category":"page"},{"location":"#JuMag.jl-1","page":"JuMag.jl","title":"JuMag.jl","text":"","category":"section"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"A Julia package for classical spin dynamics and micromagnetic simulations with GPU support.","category":"page"},{"location":"#How-the-magnetization-is-stored-in-the-array-spin?-1","page":"JuMag.jl","title":"How the magnetization is stored in the array spin?","text":"","category":"section"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"In JuMag, the magnetization is stored in a 1D array with the form m_1x m_1 y m_1 z  m_nx m_n y m_n z","category":"page"},{"location":"#How-to-get-the-global-index-of-magnetization-at-site-(i,j,k)-?-1","page":"JuMag.jl","title":"How to get the global index of magnetization at site (ijk) ?","text":"","category":"section"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"In JuMag, the global index can be obtained using the following function","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"function index(i::Int64, j::Int64, k::Int64, nx::Int64, ny::Int64, nz::Int64)\n    if i < 1 || j < 1 || k < 1 || k > nz || j > ny || i > nx\n        return -1\n    end\n    return (k-1) * nx*ny + (j-1) * nx + i\nend","category":"page"},{"location":"#How-to-get-the-effective-field-at-site-(i,j,k)?-1","page":"JuMag.jl","title":"How to get the effective field at site (ijk)?","text":"","category":"section"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"The effective field is stored in the same form of the magnetization, so the effective at site (i,j,k) can be extracted using","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"  id = index(i,j,k, nx, ny, nz)\n  fx = sim.field[3*id-2]\n  fy = sim.field[3*id-1]\n  fz = sim.field[3*id]","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"Alternatively, we can use reshape function","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"  f = reshape(sim.field, 3, nx, ny, nz)\n  fx,fy,fz = f[:, i,j,k]","category":"page"},{"location":"#How-to-run-JuMag-in-a-cluster-node-with-multiple-GPUs?-1","page":"JuMag.jl","title":"How to run JuMag in a cluster node with multiple GPUs?","text":"","category":"section"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"In the long run, JuMag will support multiple GPUs. However, here we discuss the common scenario that one needs to change some parameters systematically, such as the geometry size, or cell size, or external field, or charge current as a driving force. In these cases, the simulation can be run in parallel since they are independent tasks. Here is a demo that using 4 GPUs to relax the system with different sizes. ","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"@everywhere using JuMag\n@everywhere using Printf\n@everywhere using CUDAnative\n\n@everywhere function relax_system(Nx, gpu_id)\n\n  device!(gpu_id)  #using the gpu with gpu_id\n\n  mesh =  FDMeshGPU(nx=Nx, ny=50, nz=1, dx=2.5e-9, dy=2.5e-9, dz=3e-9)\n\n  name = @sprintf(\"Nx_%d\", Nx)\n  sim = Sim(mesh, name=name, driver=\"SD\")\n  set_Ms(sim, 8.0e5)\n  sim.driver.min_tau = 1e-10\n\n  add_exch(sim, 1.3e-11)\n  add_demag(sim)\n\n  init_m0(sim, (1, 0.25, 0.1))\n\n  relax(sim, maxsteps=5000, stopping_torque=1.0)\n\n  return nothing\nend\n\nNx = [i for i in 200:20:400]\nfor i = 1:4:length(Nx)\n    r1 = remotecall(relax_system, 1, Nx[i], 0)\n    r2 = remotecall(relax_system, 2, Nx[i+1], 1)\n    r3 = remotecall(relax_system, 3, Nx[i+2], 2)\n    r4 = remotecall(relax_system, 4, Nx[i+3], 3)\n    fetch(r1)\n    fetch(r2)\n    fetch(r3)\n    fetch(r4)\nend","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"Here is the corresponding Slurm script:","category":"page"},{"location":"#","page":"JuMag.jl","title":"JuMag.jl","text":"#!/bin/bash\n#SBATCH --nodes=1             # Number of nodes\n#SBATCH --ntasks=1            # Number of tasks?\n#SBATCH --cpus-per-task=4     # Number of CPUs per task\n#SBATCH --gres=gpu:4          # Number of GPUs\nsrun julia -p 4 main.jl","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#An-example-–-vortex-1","page":"Tutorial","title":"An example – vortex","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To start a micromagnetic simulation, we first create a FDMesh","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"mesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After that, we create a simulation","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"sim = Sim(mesh, name=\"vortex\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and set the damping to 0.5 and switch off the precession term in LLG equation:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"sim.driver.alpha = 0.5\nsim.driver.precession = false","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The geometry of the system can be defined by","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"set_Ms(sim, circular_Ms)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"where circular_Ms could be a scalar or a function. The function should take six parameters (i,j,k,dx,dy,dz), for instance","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function circular_Ms(i,j,k,dx,dy,dz)\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8.6e5\n    end\n    return 0.0\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We add the exchange interaction and the demagnetization field to the system.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"add_exch(sim, 1.3e-11)\nadd_demag(sim)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We need to initialise the system which can be done by defining a function","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function init_fun(i,j,k,dx,dy,dz)\n  x = i-50.5\n  y = j-50.5\n  r = (x^2+y^2)^0.5\n  if r<5\n    return (0,0,1)\n  end\n  return (y/r, -x/r, 0)\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and using","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"init_m0(sim, init_fun)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To trigger the simulation we relax the system","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"relax(sim, maxsteps=1000)","category":"page"},{"location":"tutorial/#How-to-enable-GPU-1","page":"Tutorial","title":"How to enable GPU","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using FDMeshGPU instead of FDMesh to switch on the GPU calculation,","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"mesh = FDMeshGPU(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The script to use GPU to obtain the vortex structure is shown below:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using JuMag\nusing Printf\nusing NPZ\n\nJuMag.cuda_using_double(true)\nmesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)\n\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    x = i-50.5\n    y = j-50.5\n    r = (x^2+y^2)^0.5\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8e5\n    end\n    return 0.0\nend\n\nfunction init_fun(i,j,k,dx,dy,dz)\n  x = i-50.5\n  y = j-50.5\n  r = (x^2+y^2)^0.5\n  if r<5\n    return (0,0,1)\n  end\n  return (y/r, -x/r, 0)\nend\n\nfunction relax_system()\n  sim = Sim(mesh, driver=\"SD\", name=\"sim\")\n  set_Ms(sim, circular_Ms)\n\n  add_exch(sim, 1.3e-11, name=\"exch\")\n  add_demag(sim)\n\n  init_m0(sim, init_fun)\n  relax(sim, maxsteps=2000, stopping_torque=1.0, save_vtk_every = 100, save_m_every=-1)\n  npzwrite(\"m0.npy\", sim.spin)\nend\n\nrelax_system()","category":"page"},{"location":"tutorial/#Standard-Problem-#4-1","page":"Tutorial","title":"Standard Problem #4","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using JuMag\nusing Printf\nusing NPZ\n\nmesh =  FDMeshGPU(nx=200, ny=50, nz=1, dx=2.5e-9, dy=2.5e-9, dz=3e-9)\n\nfunction relax_system(mesh)\n  sim = Sim(mesh, name=\"std4_relax\", driver=\"SD\")\n  set_Ms(sim, 8.0e5)\n  sim.driver.min_tau = 1e-10\n\n  add_exch(sim, 1.3e-11)\n  add_demag(sim)\n\n  init_m0(sim, (1, 0.25, 0.1))\n\n  relax(sim, maxsteps=5000, stopping_torque=10.0)\n  npzwrite(\"m0.npy\", Array(sim.spin))\nend\n\nfunction apply_field1(mesh)\n  sim = Sim(mesh, name=\"std4_dyn\")\n  set_Ms(sim, 8.0e5)\n  sim.driver.alpha = 0.02\n  sim.driver.gamma = 2.211e5\n\n  mT = 0.001 / (4*pi*1e-7)\n  add_exch(sim, 1.3e-11)\n  add_demag(sim)\n  add_zeeman(sim, (-24.6*mT, 4.3*mT, 0))\n\n  init_m0(sim, npzread(\"m0.npy\"))\n\n  for i=1:100\n    run_until(sim, 1e-11*i)\n  end\nend\n\nrelax_system(mesh)\nprintln(\"Start step2 !!!\")\napply_field1(mesh)\nprintln(\"Run step2 again!!!\")\n@time apply_field1(mesh)\nprintln(\"Done!\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The output file is a simple text compatible with Gnuplot, like used for plot below.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: std4)","category":"page"},{"location":"tutorial/#A-NEB-example-(vortex-core-reversal)-1","page":"Tutorial","title":"A NEB example (vortex core reversal)","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The magnetic vortex core can either point up or point down. In this example, we will compute the energy barrier between this two states. We will use NEB (Nudged elastic band) method.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To begin, we need to prepare this two states which can be done by defining two initial functions init_m_point_up and init_m_point_down. After running the following script, two states in the format of OVF2 (up.ovf and down.ovf) will be saved.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using JuMag\nusing Printf\n\nJuMag.cuda_using_double(true)\nmesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)\n\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    x = i-50.5\n    y = j-50.5\n    r = (x^2+y^2)^0.5\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8e5\n    end\n    return 0.0\nend\n\nfunction init_m_point_up(i,j,k,dx,dy,dz)\n  x = i-50.5\n  y = j-50.5\n  r = (x^2+y^2)^0.5\n  if r<5\n    return (0,0,1)\n  end\n  return (y/r, -x/r, 0)\nend\n\nfunction init_m_point_down(i,j,k,dx,dy,dz)\n  x = i-50.5\n  y = j-50.5\n  r = (x^2+y^2)^0.5\n  if r<5\n    return (0,0,1)\n  end\n  return (y/r, -x/r, 0)\nend\n\nfunction relax_system(init_fun, name)\n  sim = Sim(mesh, driver=\"SD\", name=\"sim\")\n  set_Ms(sim, circular_Ms)\n\n  add_exch(sim, 1.3e-11, name=\"exch\")\n  add_demag(sim)\n\n  init_m0(sim, init_fun)\n  relax(sim, maxsteps=2000, stopping_torque = 1.0)\n  save_ovf(sim, name)\nend\n\nfor (init_m, name) in [(init_m_point_up, \"up\"), (init_m_point_down, \"down\")]\n  relax_system(init_m, name)\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After generating the two states we are interested in, we can use NEB method. In JuMag, we have a pure CPU version of NEB and a GPU version which supports multiple GPUs with the helper of MPI. In this example, we will use the latter, i.e., NEB_MPI. Typically, three parameters are needed to start the NEB simulation:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"sim – an instance of MicroSimGPU.\ninitm – an array that contains at least two ends states. If you have more information about the middle states, you can put it into initm array.\ninterpolations – an array to contain the number of interpolations between given states. So length(interpolations) must equal to length(init_m) - 1.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"So the typical usage is given as follows","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function relax_neb()\n    ovf1 = read_ovf(\"down.ovf\")\n    ovf2 = read_ovf(\"up.ovf\")\n    sim = create_sim()\n    init_m = [ovf1.data, ovf2.data]\n    interpolations = [12]\n    neb = NEB_MPI(sim, init_m, interpolations, driver=\"LLG\")\n    relax(neb, maxsteps=10000, stopping_dmdt = 0.5, save_ovf_every=500)\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In the function relax_neb we called create_sim which is very similar to the function relax_system, actually, two functions should have exactly the same micromagnetic parameters. Here, to save GPU memory we do not use any driver (by setting driver=\"none\") and let save_data=false when creating the Sim instance.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function create_sim()\n    mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)\n    sim = Sim(mesh, name=\"sim\", driver=\"none\", save_data=false)\n    set_Ms(sim, circular_Ms)\n    init_m0(sim, (0,0,1))\n    add_demag(sim)\n    add_exch(sim, 1.3e-11)\n    return sim\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Moreover, if you are going to use multiple GPUs, you need to add JuMag.using_multiple_gpus(), the number of GPUs will be set to the number of processes of MPI. Put it all together, the script is given by","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using JuMag\nusing CuArrays\nusing Printf\nJuMag.cuda_using_double(true)\nCuArrays.allowscalar(false)  #important for performance\n\nJuMag.using_multiple_gpus()\n\nfunction create_sim()\n    mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)\n    sim = Sim(mesh, name=\"sim\", driver=\"none\", save_data=false)\n    set_Ms(sim, circular_Ms)\n    init_m0(sim, (0,0,1))\n    add_demag(sim)\n    add_exch(sim, 1.3e-11)\n    return sim\nend\n\nfunction circular_Ms(i,j,k,dx,dy,dz)\n    x = i-50.5\n    y = j-50.5\n    r = (x^2+y^2)^0.5\n    if (i-50.5)^2 + (j-50.5)^2 <= 50^2\n        return 8e5\n    end\n    return 0.0\nend\n\nfunction relax_neb()\n    ovf1 = read_ovf(\"vortex_down.ovf\")\n    ovf2 = read_ovf(\"vortex_up.ovf\")\n    sim = create_sim()\n    neb = NEB_MPI(sim,(ovf1.data, ovf2.data),(12), driver=\"LLG\")\n    relax(neb, maxsteps=10000, stopping_dmdt=1.0, save_ovf_every=500)\nend\n\nrelax_neb()","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The Slurm script two use two GPUs:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"#!/bin/bash\n#SBATCH --nodes=1             # Number of nodes\n#SBATCH --ntasks=2            # Number of MPI processes\n#SBATCH --cpus-per-task=1     # Number of CPUs per task\n#SBATCH --gres=gpu:2          # Number of GPUs\nmpiexec -np 2 julia main.jl","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: neb_vortex)","category":"page"},{"location":"tutorial/#Monte-Carlo-(M-T-curve)-1","page":"Tutorial","title":"Monte Carlo (M-T curve)","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can use Monte Carlo to compute the M-T curve. For the atomistic model with z nearest neighbors, the relation between exchange constant and T_c reads [1]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"J = frac3 k_B T_c epsilon z ","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"where epsilon is a correction factor. For 3D classical Heisenberg model epsilon approx 0719. In this example, we will assume J=300k_B which gives T_c = 431 K. The full script is shown below.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using JuMag\nusing Random\n\nJuMag.cuda_using_double(true)\n\nfunction relax_system(T)\n  mesh =  CubicMeshGPU(nx=30, ny=30, nz=30, pbc=\"xyz\")\n  sim = MonteCarloNew(mesh, name=\"mc\")\n  init_m0(sim, (0,0,1))\n\n  add_exch(sim, J=300*k_B)\n  add_dmi(sim, D=0, D1=0)\n  add_zeeman(sim, Hx=0, Hy=0, Hz=0)\n  add_anis(sim, Ku=0, Kc=0)\n\n  sim.T = 100000\n  run_sim(sim, maxsteps=50000, save_vtk_every=-1, save_m_every=-1)\n  sim.T = T\n  run_sim(sim, maxsteps=200000, save_vtk_every=-1, save_m_every=-1)\n\n  ms = zeros(1000)\n  sim.T = T\n  for i = 1:1000\n      run_sim(sim, maxsteps=100, save_vtk_every=-1, save_m_every=-1)\n      t = JuMag.average_m(sim)\n      ms[i] = sqrt(t[1]^2+t[2]^2+t[3]^2)\n  end\n  return sum(ms)/length(ms)\nend\n\nf = open(\"M_H.txt\", \"w\")\nwrite(f, \"#T(K)     m \\n\")\nfor T = 10:20:500\n    println(\"Running for $T ...\")\n    m = relax_system(T)\n    write(f, \"$T    $m \\n\")\nend\nclose(f)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The obtained M-T curve is shown as follows, where the obtained T_c is closed to 440 K.s (Image: M_T)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"[1] Atomistic spin model simulations of magnetic nanomaterials, J. Phys.: Condens. Matter 26 (2014) 103202.","category":"page"}]
}
