<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · JuMag.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMag.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">JuMag.jl</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#An-example-–-vortex-1">An example – vortex</a></li><li><a class="toctext" href="#How-to-enable-GPU-1">How to enable GPU</a></li><li><a class="toctext" href="#Standard-Problem-#4-1">Standard Problem #4</a></li><li><a class="toctext" href="#A-NEB-example-(vortex-core-reversal)-1">A NEB example (vortex core reversal)</a></li></ul></li><li><a class="toctext" href="../equations/">Implemented equations</a></li><li><a class="toctext" href="../notes/">Notes</a></li><li><a class="toctext" href="../functions/">Function References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/ww1g11/JuMagDocs.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><h2><a class="nav-anchor" id="An-example-–-vortex-1" href="#An-example-–-vortex-1">An example – vortex</a></h2><p>To start a micromagnetic simulation, we first create a FDMesh</p><pre><code class="language-julia">mesh = FDMesh(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100)</code></pre><p>After that, we create a simulation</p><pre><code class="language-julia">sim = Sim(mesh, name=&quot;vortex&quot;)</code></pre><p>and set the damping to 0.5 and switch off the precession term in LLG equation:</p><pre><code class="language-julia">sim.driver.alpha = 0.5
sim.driver.precession = false</code></pre><p>The geometry of the system can be defined by</p><pre><code class="language-julia">set_Ms(sim, circular_Ms)</code></pre><p>where <code>circular_Ms</code> could be a scalar or a function. The function should take six parameters <code>(i,j,k,dx,dy,dz)</code>, for instance</p><pre><code class="language-julia">function circular_Ms(i,j,k,dx,dy,dz)
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8.6e5
    end
    return 0.0
end</code></pre><p>We add the exchange interaction and the demagnetization field to the system.</p><pre><code class="language-julia">add_exch(sim, 1.3e-11)
add_demag(sim)</code></pre><p>We need to initialise the system which can be done by defining a function</p><pre><code class="language-julia">function init_fun(i,j,k,dx,dy,dz)
  x = i-50.5
  y = j-50.5
  r = (x^2+y^2)^0.5
  if r&lt;5
    return (0,0,1)
  end
  return (y/r, -x/r, 0)
end</code></pre><p>and using</p><pre><code class="language-julia">init_m0(sim, init_fun)</code></pre><p>To trigger the simulation we relax the system</p><pre><code class="language-julia">relax(sim, maxsteps=1000)</code></pre><h2><a class="nav-anchor" id="How-to-enable-GPU-1" href="#How-to-enable-GPU-1">How to enable GPU</a></h2><p>Using FDMeshGPU instead of FDMesh to switch on the GPU calculation,</p><pre><code class="language-julia">mesh = FDMeshGPU(dx=2e-9, dy=2e-9, dz=2e-9, nx=100, ny=100)</code></pre><p>The script to use GPU to obtain the vortex structure is shown below:</p><pre><code class="language-julia">using JuMag
using Printf
using NPZ

JuMag.cuda_using_double(true)
mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)

function circular_Ms(i,j,k,dx,dy,dz)
    x = i-50.5
    y = j-50.5
    r = (x^2+y^2)^0.5
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8e5
    end
    return 0.0
end

function init_fun(i,j,k,dx,dy,dz)
  x = i-50.5
  y = j-50.5
  r = (x^2+y^2)^0.5
  if r&lt;5
    return (0,0,1)
  end
  return (y/r, -x/r, 0)
end

function relax_system()
  sim = Sim(mesh, driver=&quot;SD&quot;, name=&quot;sim&quot;)
  set_Ms(sim, circular_Ms)

  add_exch(sim, 1.3e-11, name=&quot;exch&quot;)
  add_demag(sim)

  init_m0(sim, init_fun)
  relax(sim, maxsteps=2000, stopping_torque=1.0, save_vtk_every = 100, save_m_every=-1)
  npzwrite(&quot;m0.npy&quot;, sim.spin)
end

relax_system()</code></pre><h2><a class="nav-anchor" id="Standard-Problem-#4-1" href="#Standard-Problem-#4-1">Standard Problem #4</a></h2><pre><code class="language-julia">using JuMag
using Printf
using NPZ

mesh =  FDMeshGPU(nx=200, ny=50, nz=1, dx=2.5e-9, dy=2.5e-9, dz=3e-9)

function relax_system(mesh)
  sim = Sim(mesh, name=&quot;std4_relax&quot;, driver=&quot;SD&quot;)
  set_Ms(sim, 8.0e5)
  sim.driver.min_tau = 1e-10

  add_exch(sim, 1.3e-11)
  add_demag(sim)

  init_m0(sim, (1, 0.25, 0.1))

  relax(sim, maxsteps=5000, stopping_torque=10.0)
  npzwrite(&quot;m0.npy&quot;, Array(sim.spin))
end

function apply_field1(mesh)
  sim = Sim(mesh, name=&quot;std4_dyn&quot;)
  set_Ms(sim, 8.0e5)
  sim.driver.alpha = 0.02
  sim.driver.gamma = 2.211e5

  mT = 0.001 / (4*pi*1e-7)
  add_exch(sim, 1.3e-11)
  add_demag(sim)
  add_zeeman(sim, (-24.6*mT, 4.3*mT, 0))

  init_m0(sim, npzread(&quot;m0.npy&quot;))

  for i=1:100
    run_until(sim, 1e-11*i)
  end
end

relax_system(mesh)
println(&quot;Start step2 !!!&quot;)
apply_field1(mesh)
println(&quot;Run step2 again!!!&quot;)
@time apply_field1(mesh)
println(&quot;Done!&quot;)</code></pre><p>The output file is a simple text compatible with <a href="http://www.gnuplot.info/">Gnuplot</a>, like used for plot below.</p><p><img src="../scripts/std4.png" alt="std4"/></p><h2><a class="nav-anchor" id="A-NEB-example-(vortex-core-reversal)-1" href="#A-NEB-example-(vortex-core-reversal)-1">A NEB example (vortex core reversal)</a></h2><p>The magnetic vortex core can either point up or point down. In this example, we will compute the energy barrier between this two states. We will use NEB (Nudged elastic band) method.</p><p>To begin, we need to prepare this two states which can be done by defining two initial functions <code>init_m_point_up</code> and <code>init_m_point_down</code>. After running the following script, two states in the format of OVF2 (<code>up.ovf</code> and <code>down.ovf</code>) will be saved.</p><pre><code class="language-julia">using JuMag
using Printf

JuMag.cuda_using_double(true)
mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)

function circular_Ms(i,j,k,dx,dy,dz)
    x = i-50.5
    y = j-50.5
    r = (x^2+y^2)^0.5
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8e5
    end
    return 0.0
end

function init_m_point_up(i,j,k,dx,dy,dz)
  x = i-50.5
  y = j-50.5
  r = (x^2+y^2)^0.5
  if r&lt;5
    return (0,0,1)
  end
  return (y/r, -x/r, 0)
end

function init_m_point_down(i,j,k,dx,dy,dz)
  x = i-50.5
  y = j-50.5
  r = (x^2+y^2)^0.5
  if r&lt;5
    return (0,0,1)
  end
  return (y/r, -x/r, 0)
end

function relax_system(init_fun, name)
  sim = Sim(mesh, driver=&quot;SD&quot;, name=&quot;sim&quot;)
  set_Ms(sim, circular_Ms)

  add_exch(sim, 1.3e-11, name=&quot;exch&quot;)
  add_demag(sim)

  init_m0(sim, init_fun)
  relax(sim, maxsteps=2000, stopping_torque = 1.0)
  save_ovf(sim, name)
end

for (init_m, name) in [(init_m_point_up, &quot;up&quot;), (init_m_point_down, &quot;down&quot;)]
  relax_system(init_m, name)
end</code></pre><p>After generating the two states we are interested in, we can use NEB method. In JuMag, we have a pure CPU version of NEB and a GPU version which supports multiple GPUs with the helper of MPI. In this example, we will use the latter, i.e., <code>NEB_MPI</code>. Typically, three parameters are needed to start the NEB simulation:</p><ul><li>sim – an instance of MicroSimGPU.</li><li>init_m – an array that contains at least two ends states. If you have more information about</li></ul><p>the middle states, you can put it into init_m array.</p><ul><li>interpolations – an array to contain the number of interpolations between given states. So</li></ul><p>length(interpolations) must equal to length(init_m) - 1.</p><p>So the typical usage is given as follows</p><pre><code class="language-none">function relax_neb()
    ovf1 = read_ovf(&quot;down.ovf&quot;)
    ovf2 = read_ovf(&quot;up.ovf&quot;)
    sim = create_sim()
    init_m = [ovf1.data, ovf2.data]
    interpolations = [12]
    neb = NEB_MPI(sim, init_m, interpolations, driver=&quot;LLG&quot;)
    relax(neb, maxsteps=10000, stopping_dmdt = 0.5, save_ovf_every=500)
end</code></pre><p>In the function <code>relax_neb</code> we called <code>create_sim</code> which is very similar to the function <code>relax_system</code>, actually, two functions should have exactly the same micromagnetic parameters. Here, to save GPU memory we do not use any driver (by setting <code>driver=&quot;none&quot;</code>) and let <code>save_data=false</code> when creating the Sim instance.</p><pre><code class="language-none">function create_sim()
    mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)
    sim = Sim(mesh, name=&quot;sim&quot;, driver=&quot;none&quot;, save_data=false)
    set_Ms(sim, circular_Ms)
    init_m0(sim, (0,0,1))
    add_demag(sim)
    add_exch(sim, 1.3e-11)
    return sim
end</code></pre><p>Moreover, if you are going to use multiple GPUs, you need to add <code>JuMag.using_multiple_gpus()</code>, the number of GPUs will be set to the number of processes of MPI. Put it all together, the script is given by</p><pre><code class="language-none">using JuMag
using CuArrays
using Printf
JuMag.cuda_using_double(true)
CuArrays.allowscalar(false)  #important for performance

JuMag.using_multiple_gpus()

function create_sim()
    mesh =  FDMeshGPU(dx=2e-9, dy=2e-9, dz=5e-9, nx=100, ny=100, nz=4)
    sim = Sim(mesh, name=&quot;sim&quot;, driver=&quot;none&quot;, save_data=false)
    set_Ms(sim, circular_Ms)
    init_m0(sim, (0,0,1))
    add_demag(sim)
    add_exch(sim, 1.3e-11)
    return sim
end

function circular_Ms(i,j,k,dx,dy,dz)
    x = i-50.5
    y = j-50.5
    r = (x^2+y^2)^0.5
    if (i-50.5)^2 + (j-50.5)^2 &lt;= 50^2
        return 8e5
    end
    return 0.0
end

function relax_neb()
    ovf1 = read_ovf(&quot;vortex_down.ovf&quot;)
    ovf2 = read_ovf(&quot;vortex_up.ovf&quot;)
    sim = create_sim()
    neb = NEB_MPI(sim,(ovf1.data, ovf2.data),(12), driver=&quot;LLG&quot;)
    relax(neb, maxsteps=10000, stopping_dmdt=1.0, save_ovf_every=500)
end

relax_neb()</code></pre><p>The Slurm script two use two GPUs:</p><pre><code class="language-none">#!/bin/bash
#SBATCH --nodes=1             # Number of nodes
#SBATCH --ntasks=2            # Number of MPI processes
#SBATCH --cpus-per-task=1     # Number of CPUs per task
#SBATCH --gres=gpu:2          # Number of GPUs
mpiexec -np 2 julia main.jl</code></pre><p><img src="../figures/neb_vortex.png" alt="neb_vortex"/></p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">JuMag.jl</span></a><a class="next" href="../equations/"><span class="direction">Next</span><span class="title">Implemented equations</span></a></footer></article></body></html>
